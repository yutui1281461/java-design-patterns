package com.iluwatar.monitor;/**  * A condition queue. * Uses the signal and wait discipline (SW) or signal and leave (SL). * Each Condition object is associated with a single {@link Assertion} object * and a single <code>AbstractMonitor</code> object. To construct a condition * use the <code>makeCondition</code> methods from * <code>{@link AbstractMonitor}</code> or {@link Monitor} * Threads can wait for the assertion represented by the Assertion object to * become true by calling method <code>await()</code>. Threads can indicate that * the assertion has become true by calling either method <code>signal()</code> * (SW) or <code>signalAndLeave()</code> (SL). All these methods check the * assertion and the monitor's invariant as appropriate. * Threads which wait on a Condition may supply a priority. In the absence of * priority, waiting is fair -- in fact first-in last-out (FIFO). * Each of the <code>await()</code>, <code>signal()</code>, and * <code>signalAndLeave()</code> methods have corresponding conditional * versions, which first check the assertion before awaiting or signalling. * These are: <code>conditionalAwait()</code>, <code>conditionalSignal()</code>, * and <code>conditionalSignalAndLeave()</code>. * Conditions also support a {@link #count} accessor to determine the number of * threads waiting on the condition. * Condition objects are intended to be used only by the thread which occupies * the monitor which created them. */public class Condition {  private final AbstractMonitor homeMonitor;  private final Assertion assertion;  private final Semaphore queue;  private volatile int count;  private final String name;  Condition(String name, AbstractMonitor homeMonitor, Assertion assertion) {    this.name = name;    this.homeMonitor = homeMonitor;    this.assertion = assertion;    this.queue = new Semaphore(0);    this.count = 0;  }  public String getName() {    return name;  }  /**   * Just like await, but with a priority. Threads awaiting with a lesser priority   * value are re-admitted to the monitor in preference to threads awaiting with a   * greater priority value. When priority values are the same, the order is FIFO.   *    * @param priority   *            Lower value means more urgent.   * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if the invariant is not true to start   * @throws AssertionError   *             if the assertion is not true on return   * @see #await()   */  public void await(int priority) {    homeMonitor.notifyCallAwait(this);    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    count += 1;    Assertion.check(homeMonitor.invariant(), "Invariant of monitor " + homeMonitor.getName());    homeMonitor.occupant = null;    homeMonitor.entrance.release();    queue.acquire(priority);    count -= 1;    homeMonitor.occupant = Thread.currentThread();    // It's not clear that the following check is needed anymore,    // as there is now a check made on the signal.    assertion.check();    homeMonitor.notifyReturnFromAwait(this);  }  /**   * Wait until a condition is signalled. The thread waits outside the monitor   * until the condition is signalled.   * Precondition: Increasing the count by 1 must make the invariant true. This   * thread is in the monitor.   * Postcondition: The assertion associated with this condition queue. This   * thread is in the monitor.   * Note: threads are queued in a FIFO manner unless a priority is used;   * <kbd>cond.await()</kbd> is equivalent to <kbd>cond.await( Integer.MAX_VALUE   * )</kbd>.   *    * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if the invariant is not true to start   * @throws AssertionError   *             if the assertion is not true on return   */  public void await() {    await(Integer.MAX_VALUE);  }  /**   * Wait only if the condition is not already true.   *    * @throws AssertionError   *             if neither the invariant nor the assertion associated with this   *             object is true   * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if the assertion is not true on return   * @see #await()   */  public void conditionalAwait() {    conditionalAwait(Integer.MAX_VALUE);  }  /**   * Just like conditionalAwait, but with a priority.   *    * @param priority   *            Lower value means more urgent.   * @throws AssertionError   *             if neither the invariant nor the assertion associated with this   *             object is true   * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if the assertion is not true on return   * @see #conditionalAwait()   * @see #await( int priority )   *    */  public void conditionalAwait(int priority) {    if (!assertion.isTrue()) {      await(priority);    }  }  /**   * Signal this condition if there is a waiting thread.   * Allows one thread that was waiting on the condition to reenter the monitor.   * Consequently the signalling thread waits outside. The signalling thread is   * allowed back into the monitor, once the monitor is again unoccupied. Threads   * which have signalled wait with a higher than normal priority and thus are   * allowed in ahead of other threads that are waiting to enter the monitor   * (e.g., those waiting in {@link AbstractMonitor#enter()}).   * If there is no waiting thread, then this is a no-op, but the invariant is   * still checked, as it is a postcondition.   * Preconditions:   * <ul>   * <li>If isEmpty(), the monitor's invariant must be true.</li>   * <li>If not isEmpty(), then decreasing count() by 1 must make the proposition   * associated with this condition true.</li>   * <li>This thread is in the monitor.</li>   * </ul>   * Postcondition:   * <ul>   * <li>The monitor's invariant.   * <li>This thread is in the monitor.   * </ul>   *    * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if there is a waiting thread and the assertion is false (after   *             decreasing the count by 1).   * @throws AssertionError   *             if invariant is false on return.   *    */  public void signal() {    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    if (count > 0) {      try {        count -= 1;        assertion.check();      } finally {        count += 1;      }      homeMonitor.notifySignallerLeavesTemporarily(this);      homeMonitor.notifySignallerAwakesAwaitingThread(this);      homeMonitor.occupant = null;      queue.release();      homeMonitor.entrance.acquire(0); // Priority 0 puts the signaller ahead of others.      homeMonitor.occupant = Thread.currentThread();      homeMonitor.notifySignallerReenters(this);    }    Assertion.check(homeMonitor.invariant(), "Invariant of monitor " + homeMonitor.getName());  }  /**   * Allows one thread which was waiting on the condition to reenter the monitor.   * This thread (the one calling signalAndLeave) leaves the monitor immediately.   * Preconditions:   * <ul>   * <li>If isEmpty(), the monitor's invariant must be true.</li>   * <li>If not isEmpty(), then decreasing count() by 1 must make the proposition   * associated with this condition true.</li>   * <li>This thread is in the monitor.</li>   * </ul>   * Postcondition: This thread is not in the monitor.   *    * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if there is a waiting thread and the assertion is false (after   *             decreasing the count by 1).   * @throws AssertionError   *             if there is no waiting thread and the invariant is false.   * @see #signal()   */  public void signalAndLeave() {    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    if (count > 0) {      try {        count -= 1;        assertion.check();      } finally {        count += 1;      }      homeMonitor.notifySignallerAwakesAwaitingThread(this);      homeMonitor.occupant = null;      queue.release();    } else {      Assertion.check(homeMonitor.invariant(), "Invariant of monitor " + homeMonitor.getName());      homeMonitor.occupant = null;      homeMonitor.entrance.release();    }    homeMonitor.notifySignallerLeavesMonitor(this);  }  /**   * Signal if there is a waiting thread, then leave the monitor. Allows one   * thread which was waiting on the condition to reenter the monitor. This thread   * (the one calling signalAndLeave) leaves the monitor immediately.   * Preconditions:   * <ul>   * <li>If isEmpty(), the monitor's invariant must be true.</li>   * <li>If not isEmpty(), then decreasing count() by 1 must make the proposition   * associated with this condition true.</li>   * <li>This thread is in the monitor.</li>   * </ul>   * Postcondition: This thread is not in the monitor.   *    * @param result   *            A value to return.   * @return The value of the <kbd>result</kbd> parameter.   * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if there is a waiting thread and the assertion is false (after   *             decreasing the count by 1).   * @throws AssertionError   *             there is no waiting thread and the invariant is false.   */  public <T> T signalAndLeave(T result) {    signalAndLeave();    return result;  }  /**   * Signal this condition if its assertion is true and there is a waiting thread.   * More precisely the condition is only signalled if its assertion would be true   * after the count is decreased by 1 and there is a waiting tread.   * In such a case, the signalling thread waits outside. The signalling thread is   * allowed back into the monitor, once the monitor is again unoccupied. Threads   * which have signalled wait with a higher than normal priority and thus are   * allowed in ahead of other threads that are waiting to enter the monitor   * (e.g., those waiting in {@link AbstractMonitor#enter()}).   * If the there are no awaiting threads, or the condition's assertion would not   * be true after the count were decreased by one, this method is essentially a   * no-op, although the invariant is still checked in such a case.   * Preconditions:   * <ul>   * <li>If isEmpty(), the monitor's invariant must be true.</li>   * <li>This thread is in the monitor.</li>   * </ul>   * Postcondition:   * <ul>   * <li>The monitor's invariant.   * <li>This thread is in the monitor.   * </ul>   *    * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             if invariant is false on return.   * @see #signal()   */  public void conditionalSignal() {    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    if (count > 0) {      boolean wouldBeTrue;      count -= 1;      wouldBeTrue = assertion.isTrue();      count += 1;      if (wouldBeTrue) {        homeMonitor.notifySignallerAwakesAwaitingThread(this);        homeMonitor.notifySignallerLeavesTemporarily(this);        homeMonitor.occupant = null;        queue.release();        homeMonitor.entrance.acquire();        homeMonitor.occupant = Thread.currentThread();        homeMonitor.notifySignallerReenters(this);      }    }    Assertion.check(homeMonitor.invariant(), "Invariant of monitor " + homeMonitor.getName());  }  /**   * Signal this condition if its assertion is true and there is a waiting thread;   * leave regardless.   * More precisely the condition is only signalled if the assertion would be true   * after the count is decreased by 1 and there is a waiting thread.   * This thread (the one calling signalAndLeave) leaves the monitor immediately.   * Preconditions:   * <ul>   * <li>If isEmpty() or the assertion would be false after decreasing the count   * by 1, the monitor's invariant must be true.</li>   * <li>This thread is in the monitor.</li>   * </ul>   * Postcondition:   * <ul>   * <li>This thread is not in the monitor.   * </ul>   *    * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             there is no waiting thread and the invariant is false.   * @throws AssertionError   *             if there is a waiting thread and the assertion is false (after   *             decreasing the count by 1) and the invariant is false.   * @see #signalAndLeave()   * @see #conditionalSignal()   *   */  public void conditionalSignalAndLeave() {    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    if (count > 0) {      boolean wouldBeTrue;      count -= 1;      wouldBeTrue = assertion.isTrue();      count += 1;      if (wouldBeTrue) {        homeMonitor.notifySignallerAwakesAwaitingThread(this);        homeMonitor.notifySignallerLeavesMonitor(this);        homeMonitor.occupant = null;        queue.release();      } else {        homeMonitor.notifySignallerLeavesMonitor(this);        homeMonitor.leaveWithoutATrace();      }    } else {      homeMonitor.notifySignallerLeavesMonitor(this);      homeMonitor.leaveWithoutATrace();    }  }  /**   * Signal this condition if its assertion is true and there is a waiting thread.   * Leave regardless. More precisely the condition is only signalled if the   * assertion would be true after the count is decreased by 1.   * This thread (the one calling signalAndLeave) leaves the monitor immediately.   * Preconditions:   * <ul>   * <li>If isEmpty() or the assertion would be false after decreasing the count   * by 1, the monitor's invariant must be true.</li>   * <li>This thread is in the monitor.</li>   * </ul>   * Postcondition:   * <ul>   * <li>This thread is not in the monitor.   * </ul>   *    * @param result   *            A value to be returned.   * @return The value of the <kbd>result</kbd> parameter.   * @throws AssertionError   *             if the current thread is not the occupant.   * @throws AssertionError   *             there is no waiting thread and the invariant is false.   * @throws AssertionError   *             if there is a waiting thread and the assertion is false (after   *             decreasing the count by 1) and the invariant is false.   * @see #conditionalSignalAndLeave()   *   */  public <T> T conditionalSignalAndLeave(T result) {    conditionalSignalAndLeave();    return result;  }  /**   * Test if any thread is waiting on this condition.   *    * @return count() == 0 .   * @throws AssertionError   *             if the current thread is not the occupant.   */  public boolean isEmpty() {    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    return count == 0;  }  /**   * How many threads are waiting on this condition.   *    * @return the number of Threads waiting on this condition.   * @throws AssertionError   *             if the current thread is not the occupant.   */  public int count() {    Assertion.check(homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant");    return count;  }}